import{_ as a,z as s,o as e,D as i}from"./chunks/framework.CEZ28rDC.js";const k=JSON.parse('{"title":"CSS实现页面的整页滚动","description":"CSS实现页面的整页滚动","frontmatter":{"id":1730687008377,"title":"CSS实现页面的整页滚动","description":"CSS实现页面的整页滚动","tag":"CSS","archive":null,"recommendations":null,"shadow":false,"top":0},"headers":[],"relativePath":"@FullPageScrolling.md","filePath":"@FullPageScrolling.md"}'),l={name:"@FullPageScrolling.md"};function n(r,t,d,h,o,p){return e(),s("div",null,t[0]||(t[0]=[i('<h1 id="css-实现页面的整页滚动" tabindex="-1">CSS 实现页面的整页滚动 <a class="header-anchor" href="#css-实现页面的整页滚动" aria-label="Permalink to &quot;CSS 实现页面的整页滚动&quot;">​</a></h1><p>整页滚动（也称为全屏滚动、单页滚动或视差滚动）是一种网页导航和布局技术，它允许用户通过滚动鼠标滚轮、点击导航链接或触摸移动设备屏幕来在网页的不同部分（通常是全屏高度的“页面”或“部分”）之间平滑过渡。</p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><p>只要依靠 css 中的 <code>scroll-snap-type</code> 和 <code>scroll-snap-align</code> 属性。</p><h4 id="scroll-snap-type" tabindex="-1">scroll-snap-type <a class="header-anchor" href="#scroll-snap-type" aria-label="Permalink to &quot;scroll-snap-type&quot;">​</a></h4><p>设置了在有滚动容器的情形下吸附至吸附点的严格程度。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scroll-snap-type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> none</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inline </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> both ] [ mandatory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proximity ]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">?</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:center;">scroll-snap-type</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">none</td><td>在滚动此滚动容器的可见视口时，必须忽略吸附点。</td></tr><tr><td style="text-align:center;">x</td><td>滚动容器仅在其横轴上吸附至吸附位置。</td></tr><tr><td style="text-align:center;">y</td><td>滚动容器仅在其纵轴上吸附至吸附位置。</td></tr><tr><td style="text-align:center;">block</td><td>滚动容器仅在其块向轴上吸附至吸附位置。</td></tr><tr><td style="text-align:center;">inline</td><td>滚动容器仅在其行向轴上吸附至吸附位置。</td></tr><tr><td style="text-align:center;">both</td><td>滚动容器在其两轴上独立地吸附至吸附位置（可能在各轴上吸附至不同的元素）。</td></tr><tr><td style="text-align:center;">mandatory</td><td>若滚动容器当前未在滚动，则其可见视口必须吸附至吸附位置。</td></tr><tr><td style="text-align:center;">poximity</td><td>若滚动容器当前未在滚动，则其可见视口可以吸附至吸附位置。是否吸附由用户代理根据滚动参数决定。若指定了吸附轴，则此为默认的吸附程度</td></tr></tbody></table><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type" target="_blank" rel="noreferrer">MDN scroll-snap-type</a></li></ol>',12)]))}const g=a(l,[["render",n]]);export{k as __pageData,g as default};
